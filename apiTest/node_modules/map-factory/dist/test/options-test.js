"use strict";

var _code = require("code");

var _lab = require("lab");

var Lab = _interopRequireWildcard(_lab);

var _labTesting = require("lab-testing");

var _labTesting2 = _interopRequireDefault(_labTesting);

var _index = require("../lib/index");

var _index2 = _interopRequireDefault(_index);

var _existingModifierSuite = require("./suites/existing-modifier-suite");

var _existingModifierSuite2 = _interopRequireDefault(_existingModifierSuite);

var _alwaysModifierSuite = require("./suites/always-modifier-suite");

var _alwaysModifierSuite2 = _interopRequireDefault(_alwaysModifierSuite);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var lab = exports.lab = Lab.script();
var testing = (0, _labTesting2.default)(lab);
var group = testing.createExperiment("The createMapper() method");

group("when setting options", function () {

  lab.test("sets the defaults correctly when no options are provided", function () {

    var map = (0, _index2.default)();

    var mapping = map("a");

    (0, _code.expect)(mapping).to.be.an.object();
    (0, _code.expect)(mapping.alwaysSet).to.be.false();
    (0, _code.expect)(mapping.alwaysTransform).to.be.false();
    (0, _code.expect)(mapping.flatten).to.be.null();
    (0, _code.expect)(mapping.flattenInverted).to.be.false();
  });

  lab.test("sets the defaults correctly when empty options are provided", function () {

    var map = (0, _index2.default)({});

    var mapping = map("a");

    (0, _code.expect)(mapping).to.be.an.object();
    (0, _code.expect)(mapping.alwaysSet).to.be.false();
    (0, _code.expect)(mapping.alwaysTransform).to.be.false();
    (0, _code.expect)(mapping.flatten).to.be.null();
    (0, _code.expect)(mapping.flattenInverted).to.be.false();
  });

  lab.test("sets the alwaysTransform option correctly", function () {

    var map = (0, _index2.default)({ alwaysTransform: true });

    var mapping = map("a");

    (0, _code.expect)(mapping).to.be.an.object();
    (0, _code.expect)(mapping.alwaysSet).to.be.false();
    (0, _code.expect)(mapping.alwaysTransform).to.be.true();
    (0, _code.expect)(mapping.flatten).to.be.null();
    (0, _code.expect)(mapping.flattenInverted).to.be.false();
  });

  lab.test("sets the alwaysSet option correctly", function () {

    var map = (0, _index2.default)({ alwaysSet: true });

    var mapping = map("a");

    (0, _code.expect)(mapping).to.be.an.object();
    (0, _code.expect)(mapping.alwaysSet).to.be.true();
    (0, _code.expect)(mapping.alwaysTransform).to.be.false();
    (0, _code.expect)(mapping.flatten).to.be.null();
    (0, _code.expect)(mapping.flattenInverted).to.be.false();
  });

  lab.test("sets the flattenInverted option correctly", function () {

    var map = (0, _index2.default)({ flattenInverted: true });

    var mapping = map("a");

    (0, _code.expect)(mapping).to.be.an.object();
    (0, _code.expect)(mapping.alwaysSet).to.be.false();
    (0, _code.expect)(mapping.alwaysTransform).to.be.false();
    (0, _code.expect)(mapping.flatten).to.be.null();
    (0, _code.expect)(mapping.flattenInverted).to.be.true();
  });

  lab.test("sets the flatten option correctly", function () {

    var map = (0, _index2.default)({ flatten: true });

    var mapping = map("a");

    (0, _code.expect)(mapping).to.be.an.object();
    (0, _code.expect)(mapping.alwaysSet).to.be.false();
    (0, _code.expect)(mapping.alwaysTransform).to.be.false();
    (0, _code.expect)(mapping.flatten).to.be.true();
    (0, _code.expect)(mapping.flattenInverted).to.be.false();
  });

  lab.test("the existing modifier sets more alwaysSet and alwaysTransform to false", function () {

    var map = (0, _index2.default)({ alwaysSet: true, alwaysTransform: true });

    var mapping = map("a").existing;

    (0, _code.expect)(mapping).to.be.an.object();
    (0, _code.expect)(mapping.alwaysSet).to.be.false();
    (0, _code.expect)(mapping.alwaysTransform).to.be.false();
  });

  lab.test("the always modifier sets more alwaysSet and alwaysTransform to true", function () {

    var map = (0, _index2.default)({ alwaysSet: false, alwaysTransform: false });

    var mapping = map("a").always;

    (0, _code.expect)(mapping).to.be.an.object();
    (0, _code.expect)(mapping.alwaysSet).to.be.true();
    (0, _code.expect)(mapping.alwaysTransform).to.be.true();
  });
});

group("when executing with options set, the single source mapper", function () {

  lab.test("suppresses a transform when the source value is not present", function () {

    var source = {
      "my": {
        "source": {
          "is": {}
        }
      }
    };

    var expected = {
      "your": {
        "source": {
          "is": {}
        }
      }
    };

    var map = (0, _index2.default)({ alwaysTransform: false, alwaysSet: true });

    map("my.source.is.missing").to("your.source.is.missing", function () {
      return "found";
    });

    var actual = map.execute(source);

    (0, _code.expect)(actual).to.equal(expected);
  });

  lab.test("suppresses a set when the source value is not present", function () {

    var source = {
      "my": {
        "source": {
          "is": {}
        }
      }
    };

    var expected = {};

    var map = (0, _index2.default)({ alwaysTransform: false, alwaysSet: false });
    var count = 0;

    map("my.source.is.missing").to("your.source.is.missing", function () {
      count++;
      return "found";
    });

    var actual = map.execute(source);

    (0, _code.expect)(actual).to.equal(expected);
    (0, _code.expect)(count).to.equal(0);
  });

  lab.test("a set is not supressed when the source value is not present if a transform returns a value", function () {

    var source = {
      "my": {
        "source": {
          "is": {}
        }
      }
    };

    var expected = {
      "your": {
        "source": {
          "is": {
            "missing": "found"
          }
        }
      }
    };

    var map = (0, _index2.default)({ alwaysTransform: true, alwaysSet: false });

    map("my.source.is.missing").to("your.source.is.missing", function () {
      return "found";
    });

    var actual = map.execute(source);

    (0, _code.expect)(actual).to.equal(expected);
  });

  lab.test("if a transform returns undefined a set will be called", function () {

    var source = {
      "my": {
        "source": {
          "is": {}
        }
      }
    };

    var expected = {
      "your": {
        "source": {
          "is": {}
        }
      }
    };

    var map = (0, _index2.default)({ alwaysTransform: true, alwaysSet: true });

    map("my.source.is.missing").to("your.source.is.missing", function () {
      return undefined;
    });

    var actual = map.execute(source);

    (0, _code.expect)(actual).to.equal(expected);
  });

  lab.test("if source value is false set will be called", function () {

    var source = {
      "my": {
        "source": {
          "is": {
            "missing": false
          }
        }
      }
    };

    var expected = {
      "your": {
        "source": {
          "is": {
            "missing": false
          }
        }
      }
    };

    var map = (0, _index2.default)({ alwaysTransform: false, alwaysSet: false });

    map("my.source.is.missing").to("your.source.is.missing");

    var actual = map.execute(source);

    (0, _code.expect)(actual).to.equal(expected);
  });

  group("multiple mappings and arrays", function () {
    lab.test("when two mappings have an array as the first mapping", function () {

      var mapper = (0, _index2.default)({ alwaysSet: true });

      var source = {
        foo: 0,
        bar: []
      };

      var expected = { bar: [], foo: 0 };

      mapper.map("bar").to("bar[]").map("foo");

      var actual = mapper.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("when two mappings have an array as the second mapping", function () {

      var mapper = (0, _index2.default)({ alwaysSet: true });

      var source = {
        foo: 0,
        bar: []
      };

      var expected = { bar: [], foo: 0 };

      mapper.map("foo").map("bar").to("bar[]");

      var actual = mapper.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });
  });
});

group("when executing with options set, the multi source mapper", function () {

  lab.test("suppresses a transform when the source values are all not present", function () {

    var source = {
      "my": {
        "source": {
          "is": {}
        },
        "other": {
          "source": {
            "is": {}
          }
        }
      }
    };

    var expected = {
      "your": {
        "source": {
          "is": {}
        }
      }
    };

    var map = (0, _index2.default)({ alwaysTransform: false, alwaysSet: true });

    map(["my.source.is.missing", "my.other.source.is.missing"]).to("your.source.is.missing", function () {
      return "found";
    });

    var actual = map.execute(source);

    (0, _code.expect)(actual).to.equal(expected);
  });

  lab.test("suppresses a set if a transform returns null", function () {

    var source = {
      "my": {
        "source": {
          "is": {}
        },
        "other": {
          "source": {
            "is": {
              "here": "value"
            }
          }
        }
      }
    };

    var expected = {};

    var map = (0, _index2.default)({ alwaysTransform: false, alwaysSet: false });
    var count = 0;

    map(["my.source.is.missing", "my.other.source.is.here"]).to("your.source.is.missing", function () {
      count++;
      return null;
    });

    var actual = map.execute(source);

    (0, _code.expect)(actual).to.equal(expected);
    (0, _code.expect)(count).to.equal(1);
  });

  lab.test("suppresses a set if a transform returns undefined", function () {

    var source = {
      "my": {
        "source": {
          "is": {}
        },
        "other": {
          "source": {
            "is": {
              "here": "value"
            }
          }
        }
      }
    };

    var expected = {};

    var map = (0, _index2.default)({ alwaysTransform: false, alwaysSet: false });

    var count = 0;

    map(["my.source.is.missing", "my.other.source.is.here"]).to("your.source.is.missing", function () {
      count++;
      return undefined;
    });

    var actual = map.execute(source);

    (0, _code.expect)(actual).to.equal(expected);
    (0, _code.expect)(count).to.equal(1);
  });

  lab.test("a transform executes when one source value is present", function () {

    var source = {
      "my": {
        "source": {
          "is": {
            "here": "value"
          }
        },
        "other": {
          "source": {
            "is": {}
          }
        }
      }
    };

    var expected = {
      "your": {
        "source": {
          "is": {
            "here": "found"
          }
        }
      }
    };

    var map = (0, _index2.default)({ alwaysTransform: false, alwaysSet: true });

    map(["my.source.is.here", "my.other.source.is.missing"]).to("your.source.is.here", function () {
      return "found";
    });

    var actual = map.execute(source);

    (0, _code.expect)(actual).to.equal(expected);
  });
});

group("when executing with options set, the or-mode source map", function () {

  lab.test("a transform executes when no sources are present but alwaysTransform is true", function () {

    var source = {
      "my": {
        "source": {
          "is": {}
        },
        "other": {
          "source": {
            "is": {}
          }
        }
      }
    };

    var expected = {
      "your": {
        "source": {
          "is": {
            "here": "found"
          }
        }
      }
    };

    var map = (0, _index2.default)({ alwaysTransform: true, alwaysSet: false });

    map("my.source.is.here").or("my.other.source.is.missing").to("your.source.is.here", function () {
      return "found";
    });

    var actual = map.execute(source);

    (0, _code.expect)(actual).to.equal(expected);
  });

  lab.test("a transform does not execute when no sources are present and alwaysTransform is false", function () {
    var source = {
      "my": {
        "source": {
          "is": {}
        },
        "other": {
          "source": {
            "is": {}
          }
        }
      }
    };

    var expected = {};

    var map = (0, _index2.default)({ alwaysTransform: false, alwaysSet: false });

    map("my.source.is.here").or("my.other.source.is.missing").to("your.source.is.here", function () {
      return "whoops";
    });

    var actual = map.execute(source);

    (0, _code.expect)(actual).to.equal(expected);
  });

  lab.test("no set is called when no values are present and alwaysSet is false", function () {

    var source = {
      "my": {
        "source": {
          "is": {}
        },
        "other": {
          "source": {
            "is": {}
          }
        }
      }
    };

    var expected = {};

    var map = (0, _index2.default)({ alwaysTransform: false, alwaysSet: false });

    map("my.source.is.here").or("my.other.source.is.missing").to("your.source.is.here");

    var actual = map.execute(source);

    (0, _code.expect)(actual).to.equal(expected);
  });

  lab.test("set is called when no values are present but alwaysSet is true", function () {

    var source = {
      "my": {
        "source": {
          "is": {}
        },
        "other": {
          "source": {
            "is": {}
          }
        }
      }
    };

    var expected = {
      "your": {
        "source": {
          "is": {}
        }
      }
    };
    var map = (0, _index2.default)({ alwaysTransform: false, alwaysSet: true });

    map("my.source.is.here").or("my.other.source.is.missing").to("your.source.is.here");

    var actual = map.execute(source);

    (0, _code.expect)(actual).to.equal(expected);
  });
});

group("the always modifier", function () {

  _alwaysModifierSuite2.default.run(lab, { OPTIONS: null });
  _alwaysModifierSuite2.default.run(lab, {});
  _alwaysModifierSuite2.default.run(lab, { OPTIONS: { alwaysTransform: false, alwaysSet: false } });
  _alwaysModifierSuite2.default.run(lab, { OPTIONS: { alwaysTransform: false, alwaysSet: true } });
  _alwaysModifierSuite2.default.run(lab, { OPTIONS: { alwaysTransform: true, alwaysSet: false } });
  _alwaysModifierSuite2.default.run(lab, { OPTIONS: { alwaysTransform: false, alwaysSet: true } });
});

group("the existing modifier", function () {

  _existingModifierSuite2.default.run(lab, { OPTIONS: null });
  _existingModifierSuite2.default.run(lab, {});
  _existingModifierSuite2.default.run(lab, { OPTIONS: { alwaysTransform: false, alwaysSet: false } });
  _existingModifierSuite2.default.run(lab, { OPTIONS: { alwaysTransform: false, alwaysSet: true } });
  _existingModifierSuite2.default.run(lab, { OPTIONS: { alwaysTransform: true, alwaysSet: false } });
  _existingModifierSuite2.default.run(lab, { OPTIONS: { alwaysTransform: false, alwaysSet: true } });
});

group("the failureTransform as a option for default use", function () {
  lab.test("should use the global failure transformed if its defined and failure transform is not provided as part of the mapping", function () {
    var source = {
      "foo": "name1",
      "bar": "name2",
      "fooNull": null
    };

    var expected = {
      "foo1": "bar",
      "foo2": "bar",
      "foo3": "from global",
      "fooOr": "from global",
      "foo4": "from global",
      "foo5": "from global",
      "fooNull": "foo"
    };

    var mapper = (0, _index2.default)({ failureTransform: function failureTransform(val) {
        return val === null ? "foo" : "from global";
      } });

    mapper.map("foo1").to("foo1", null, "bar").map("foo2").to("foo2", null, function () {
      return "bar";
    }).map("foo2").to("foo5").map(["foo1", "foo2"]).to("foo3", function () {
      return "check";
    }).map("foo1").or("foo2").to("fooOr").map("foo4").always.to("foo4").map("fooNull").to("fooNull");

    var actual = mapper.execute(source);

    (0, _code.expect)(actual).to.equal(expected);
  });
});
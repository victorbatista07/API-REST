"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _code = require("code");

var _labTesting = require("lab-testing");

var _labTesting2 = _interopRequireDefault(_labTesting);

var _labSuite = require("lab-suite");

var labSuite = _interopRequireWildcard(_labSuite);

var _mapFactory = require("../../lib/map-factory");

var _mapFactory2 = _interopRequireDefault(_mapFactory);

var _mapping = require("../../lib/mapping");

var _mapping2 = _interopRequireDefault(_mapping);

var _mapper = require("../../lib/mapper");

var _mapper2 = _interopRequireDefault(_mapper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var suite = labSuite.create();

suite.expect("EXPERIMENTAL").to.be.a.boolean();

suite.declare(function (lab, variables) {
  var EXPERIMENTAL = variables.EXPERIMENTAL;


  function createSut() {
    return (0, _mapFactory2.default)({ experimental: EXPERIMENTAL });
  }

  // const experimentalLabel = EXPERIMENTAL === true ? "in experimental mode" : "in normal mode";

  var testing = (0, _labTesting2.default)(lab);
  var group = testing.createExperiment("interfaces");

  group("basic functionality", function () {

    lab.test("Can map one field that exists to another", function () {

      var source = {
        "fieldName": "name1"
      };

      var expected = {
        "field": {
          "name": "name1"
        }
      };

      var map = createSut();

      map("fieldName").to("field.name");

      var actual = map.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("Throws if a null source is provided", function () {

      var map = createSut();

      map("fieldName").to("field.name");

      var throws = function throws() {

        map.execute(null);
      };

      (0, _code.expect)(throws).to.throw();
    });

    lab.test("Throws if an undefined source is provided", function () {

      var map = createSut();

      map("fieldName").to("field.name");

      var throws = function throws() {

        map.execute(undefined);
      };

      (0, _code.expect)(throws).to.throw();
    });

    lab.test("Can reuse map for different transform", function () {

      var source = {
        "fieldName": "name1"
      };

      var source2 = {
        "fieldName": "name2"
      };

      var expected = {
        "field": {
          "name": "name1"
        }
      };

      var expected2 = {
        "field": {
          "name": "name2"
        }
      };

      var map = createSut();

      map("fieldName").to("field.name");

      var actual = map.execute(source);
      var actual2 = map.execute(source2);

      (0, _code.expect)(actual).to.equal(expected);
      (0, _code.expect)(actual2).to.equal(expected2);
    });

    lab.test("Can map from a source where source name is not formatted as a string", function () {

      var source = {
        country: "PL"
      };

      var expected = {
        "country": "PL"
      };

      var map = createSut();

      map("country").to("country");

      var actual = map.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("A field that doesn't exists on the source doesn't affect the resulting object", function () {

      var source = {
        "fieldName": "name1"
      };

      var expected = {
        "field": {
          "name": "name1"
        }
      };

      var map = createSut();

      map("fieldName").to("field.name");
      map("fieldId").to("field.name");

      var actual = map.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("A field that doesn't exists on the source doesn't affect the resulting object when a pass-through transform is used", function () {

      var source = {
        "fieldName": "name1"
      };

      var expected = {
        "field": {
          "name": "name1"
        }
      };

      var map = createSut();

      map("fieldName").to("field.name");
      map("fieldId").to("field.name", function (value) {
        return value;
      });

      var actual = map.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("A null source field should map the source to destination", function () {

      var map = createSut();

      var result = map(null).execute({ "foo": "bar" });

      (0, _code.expect)(result).to.equal({ "foo": "bar" });
    });

    lab.test("A no source field is provided should map the source to destination", function () {

      var map = createSut();

      var result = map().execute({ "foo": "bar" });

      (0, _code.expect)(result).to.equal({ "foo": "bar" });
    });

    lab.test(" A null source field can be used alongside a normal mapping", function () {

      var mapper = createSut();

      mapper.map(null).to("test").map("foo").to("test.foo1");

      var result = mapper.execute({ "foo": "bar" });

      (0, _code.expect)(result).to.equal({
        "test": {
          "foo": "bar",
          "foo1": "bar"
        }
      });
    });

    lab.test("A null target field throws an error", function () {

      var map = createSut();

      var throws = function throws() {

        map("fieldName").to(null);
      };

      (0, _code.expect)(throws).to.throw(Error, "the target field name must be a string");
    });

    lab.test("The source field is used if no target field is provided", function () {

      var source = {
        "fieldName": "name1"
      };

      var map = createSut();

      map("fieldName");

      var actual = map.execute(source);

      (0, _code.expect)(actual).to.equal(source);
    });

    lab.test("A source field can be mapped multiple times", function () {

      var source = {
        "fieldName": "name"
      };

      var expected = {
        "field": "name",
        "name": "name-long"
      };

      var map = createSut();

      map("fieldName").to("field");
      map("fieldName").to("name", function (value) {
        return value + "-long";
      });

      var actual = map.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });
  });

  group("alternate interfaces", function () {

    lab.test("default function and map() function are logically equivalent", function () {

      var source = {
        "fieldName": "name1"
      };

      var expected = {
        "field": {
          "name": "name1"
        }
      };

      var map = createSut();
      var mapper = createSut();

      map("fieldName").to("field.name");
      mapper.map("fieldName").to("field.name");

      var defaultActual = map.execute(source);
      var functionActual = mapper.execute(source);

      (0, _code.expect)(defaultActual).to.equal(expected);
      (0, _code.expect)(defaultActual).to.equal(functionActual);
    });
  });

  group("fluent chaining ", function () {

    lab.test("map() returns a chainable object", function () {

      var mapper = createSut();

      var actual = mapper.map("userId");

      (0, _code.expect)(actual).to.not.be.null();
      (0, _code.expect)(actual).to.be.instanceOf(_mapping2.default);
    });

    lab.test("to() returns a chainable object", function () {

      var mapper = createSut();

      var actual = mapper.map("userId").to("user.id");

      (0, _code.expect)(actual).to.not.be.null();
      (0, _code.expect)(actual).to.be.instanceOf(_mapper2.default);
    });

    lab.test("to() with a function returns a chainable object", function () {

      var mapper = createSut();

      var actual = mapper.map("userId").to("user.id", function () {
        return "a";
      });

      (0, _code.expect)(actual).to.not.be.null();
      (0, _code.expect)(actual).to.be.instanceOf(_mapper2.default);
    });

    lab.test("mapper can fluently chain call map() after the map() method", function () {

      var source = {
        "userId": 123,
        "userName": "my name"
      };

      var expected = {
        "userId": 123,
        "name": "my name"
      };

      var mapper = createSut();

      mapper.map("userId").map("userName").to("name");

      var actual = mapper.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("mapper can fluently chain call map() after the to() method", function () {

      var source = {
        "userId": 123,
        "userName": "my name"
      };

      var expected = {
        "id": 123,
        "name": "my name"
      };

      var mapper = createSut();

      mapper.map("userId").to("id").map("userName").to("name");

      var actual = mapper.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("mapper can fluently chain call execute() after the to() method", function () {

      var source = {
        "userId": 123,
        "userName": "my name"
      };

      var expected = {
        "id": 123,
        "name": "my name"
      };

      var mapper = createSut();

      var actual = mapper.map("userId").to("id").map("userName").to("name").execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("mapper can fluently chain call execute() after the map() method", function () {

      var source = {
        "userId": 123
      };

      var expected = {
        "userId": 123
      };

      var mapper = createSut();

      var actual = mapper.map("userId").execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });
  });

  group("The each() method", function () {

    lab.test("Can process an array correctly", function () {
      var source = [{
        "fieldName": "name1"
      }, {
        "fieldName": "name2"
      }];

      var expected = [{
        "field": {
          "name": "name1"
        }
      }, {
        "field": {
          "name": "name2"
        }
      }];

      var map = createSut();

      map("fieldName").to("field.name");

      var actual = map.each(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("An empty array does not cause an error", function () {
      var source = [];

      var expected = [];

      var map = createSut();

      map("fieldName").to("field.name");

      var actual = map.each(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("Multiple mappers can be used together", function () {
      var source = {
        one: [{ value: "a", drop: "me" }, { value: "b", drop: "me" }, { value: "c", drop: "me" }],
        two: [{ value: "a", drop: "me" }, { value: "b", drop: "me" }, { value: "c", drop: "me" }],
        three: [{ value: "a", drop: "me" }, { value: "b", drop: "me" }, { value: "c", drop: "me" }]
      };

      var expected = {
        one: [{ newOne: "a" }, { newOne: "b" }, { newOne: "c" }],
        two: [{ newOne: "a" }, { newOne: "b" }, { newOne: "c" }],
        three: [{ newOne: "a" }, { newOne: "b" }, { newOne: "c" }]
      };

      var mainMapper = createSut();
      var childMapper = createSut();

      childMapper.map("value").to("newOne");

      mainMapper.map("one").to("one", function (array) {
        return childMapper.each(array);
      }).map("two").to("two", function (array) {
        return childMapper.each(array);
      }).map("three").to("three", function (array) {
        return childMapper.each(array);
      });

      var actual = mainMapper.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("An undefined parameter does not throw an error", function () {
      var map = createSut();

      map("fieldName").to("field.name");

      (0, _code.expect)(map.each(undefined)).to.equal(null);
    });

    lab.test("A null parameter does not throw an error", function () {
      var map = createSut();

      map("fieldName").to("field.name");

      (0, _code.expect)(map.each(null)).to.equal(null);
    });

    lab.test("A non-array throws an error", function () {
      var map = createSut();
      var source = { "a": "b" };

      map("fieldName").to("field.name");

      var throws = function throws() {
        map.each(source);
      };

      (0, _code.expect)(throws).to.throw();
    });
  });

  group("source and destination", function () {

    lab.test("Can map fields from a source onto an existing destination object", function () {

      var source = {
        "fieldName": "name1"
      };

      var destination = {
        "existing": "field"
      };

      var expected = {
        "field": {
          "name": "name1"
        },
        "existing": "field"
      };

      var map = createSut();

      map("fieldName").to("field.name");

      var actual = map.execute(source, destination);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("Can map a field from source over an existing field on a destination object", function () {

      var source = {
        "fieldName": "name1"
      };

      var destination = {
        "field": {
          "name": "wrong"
        }
      };

      var expected = {
        "field": {
          "name": "name1"
        }
      };

      var map = createSut();

      map("fieldName").to("field.name");

      var actual = map.execute(source, destination);

      (0, _code.expect)(actual).to.equal(expected);
    });
  });

  group("custom functions", function () {

    lab.test("Calls a function and alters the resulting object", function () {

      var source = {
        "fieldName": "name1"
      };

      var expected = {
        "field": {
          "name": "altered"
        }
      };

      var map = createSut();

      map("fieldName").to("field.name", function () {
        return "altered";
      });

      var actual = map.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("Calls a default function and alters the resulting object", function () {

      var source = {
        "foo": "name1",
        "bar": "name2",
        "fooNull": null
      };

      var expected = {
        "foo1": "bar",
        "foo2": "bar",
        "foo3": "bar",
        "fooOr": "barOr",
        "foo4": "foo4",
        "fooNull": "true"
      };

      var mapper = createSut();

      mapper.map("foo1").to("foo1", null, "bar").map("foo2").to("foo2", null, function () {
        return "bar";
      }).map(["foo1", "foo2"]).to("foo3", function () {
        return "check";
      }, "bar").map("foo1").or("foo2").to("fooOr", null, "barOr").map("foo4").always.to("foo4", function () {
        return "foo4";
      }, function () {
        return "bar";
      }).map("foo5").to("foo5", null, function () {
        return null;
      }).map("foo6").to("foo6", null, null).map("fooNull").to("fooNull", null, function (val) {
        return val === null ? "true" : "false";
      });

      var actual = mapper.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });
  });

  group("multiple selections", function () {

    lab.test("Can extract multiple selections into a single transform", function () {

      var source = {
        "group1": {
          "name": "A"
        },
        "group2": {
          "name": "B"
        }
      };

      var expected = {
        "merged": { "names": ["A", "B"] }
      };

      var map = createSut();

      map(["group1", "group2"]).to("merged", function (group1, group2) {
        return { "names": [group1.name, group2.name] };
      });

      var actual = map.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("Can extract multiple selections into a single transform while allowing simpler mappings to work", function () {

      var source = {
        "person": {
          "name": "joe"
        },
        "group1": {
          "name": "A"
        },
        "group2": {
          "name": "B"
        }
      };

      var expected = {
        "name": "joe",
        "merged": { "groups": ["A", "B"] }
      };

      var map = createSut();

      map("person.name").to("name");
      map(["group1", "group2"]).to("merged", function (group1, group2) {
        return { "groups": [group1.name, group2.name] };
      });

      var actual = map.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("If multiple selections aren't mapped to a transform and error will occur", function () {

      var source = {
        "person": {
          "name": "joe"
        },
        "group1": {
          "name": "A"
        },
        "group2": {
          "name": "B"
        }
      };

      var map = createSut();

      map("person.name").to("name");
      map(["group1", "group2"]).to("merged");

      var throws = function throws() {

        map.execute(source);
      };

      (0, _code.expect)(throws).to.throw();
    });
  });

  group("The or() method", function () {

    lab.test("Maps the first item if it is present", function () {

      var source = {
        "fieldName": "name1"
      };

      var expected = {
        "field": {
          "name": "name1"
        }
      };

      var map = createSut();

      map("fieldName").or("noField").to("field.name");

      var actual = map.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("to method can use a transform if provided with first item", function () {
      var source = {
        "fieldName": "name1"
      };

      var expected = {
        "field": {
          "name": "altered name1"
        }
      };

      var map = createSut();

      map("fieldName").or("noField").to("field.name", function (value) {
        return "altered " + value;
      });

      var actual = map.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("Maps the second item if the first item isn't present", function () {

      var source = {
        "fieldName": "name1"
      };

      var expected = {
        "field": {
          "name": "name1"
        }
      };

      var map = createSut();

      map("noField").or("fieldName").to("field.name");

      var actual = map.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("Maps the last item in a very long chain", function () {

      var source = {
        "fieldName": "name1"
      };

      var expected = {
        "field": {
          "name": "name1"
        }
      };

      var map = createSut();

      map("a").or("b").or("c").or("d").or("e").or("fieldName").to("field.name");

      var actual = map.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("to method can use a transform if provided with subsequent item", function () {
      var source = {
        "fieldName": "name1"
      };

      var expected = {
        "field": {
          "name": "altered name1"
        }
      };

      var map = createSut();

      map("noField").or("fieldName").to("field.name", function (value) {
        return "altered " + value;
      });

      var actual = map.execute(source);

      (0, _code.expect)(actual).to.equal(expected);
    });

    lab.test("Throws if the initial source field is an array", function () {

      var map = createSut();

      var throws = function throws() {

        map(["a", "b"]).or("fieldName").to("field.name");
      };

      (0, _code.expect)(throws).to.throw();
    });

    lab.test("Throws if and subsequent source field is an array", function () {

      var map = createSut();

      var throws = function throws() {

        map("fieldName").or(["a", "b"]).to("field.name");
      };

      (0, _code.expect)(throws).to.throw();
    });

    lab.test("Throws if source is null", function () {
      var map = createSut();

      var throws = function throws() {

        map("fieldName").or(null).to("field.name");
      };

      (0, _code.expect)(throws).to.throw();
    });

    lab.test("Throws if source is undefined", function () {
      var map = createSut();

      var throws = function throws() {

        map("fieldName").or(undefined).to("field.name");
      };

      (0, _code.expect)(throws).to.throw();
    });
  });

  // PORTED TESTS

  group("ported object-mapper tests", function () {
    lab.test("mapping - map and append full array to existing mapped array", function () {
      var obj = {
        thing: [{ a: "a1", i: "b1" }, { a: "a2", i: "b2" }, { a: "a3", i: "b3" }],
        thingOther: [{ a: "a4", i: "b4" }, { a: "a5", i: "b5" }, { a: "a6", i: "b6" }]
      };

      var expected = {
        "thing2": [[{ a: "a1", i: "b1" }, { a: "a2", i: "b2" }, { a: "a3", i: "b3" }], [{ a: "a4", i: "b4" }, { a: "a5", i: "b5" }, { a: "a6", i: "b6" }]]
      };

      var map = createSut();

      map("thing").to("thing2[]+");
      map("thingOther").to("thing2[]+");

      var result = map.execute(obj);

      (0, _code.expect)(result).to.equal(expected);
    });

    lab.test("map object to another - allow null values", function () {
      var obj = {
        "a": 1234,
        "foo": {
          "bar": null
        }
      };

      var expected = {
        foo: {
          a: 1234
        },
        bar: {
          bar: null
        }
      };

      var map = createSut();

      map("foo.bar").always.to("bar.bar?");
      map("a").to("foo.a");

      var result = map.execute(obj);

      (0, _code.expect)(result).to.equal(expected);
    });

    lab.test("map object to another - with three destinations for same value", function () {
      var baseObject = {
        test: 1
      };

      var obj = {
        "foo": {
          "bar": "baz"
        }
      };

      var expected = {
        test: 1,
        bar: {
          foo: [{
            baz: "baz",
            foo: "baz",
            bar: ["baz"]
          }]
        }
      };

      var map = createSut();

      map("foo.bar").to("bar.foo[].baz");
      map("foo.bar").to("bar.foo[].foo");
      map("foo.bar").to("bar.foo[].bar[]");

      var result = map.execute(obj, baseObject);

      (0, _code.expect)(result).to.equal(expected);
    });
  });
});

exports.default = suite;
"use strict";

var _lab = require("lab");

var Lab = _interopRequireWildcard(_lab);

var _code = require("code");

var _lib = require("../lib");

var _lib2 = _interopRequireDefault(_lib);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var _exports$lab = exports.lab = Lab.script(),
    describe = _exports$lab.describe,
    it = _exports$lab.it,
    before = _exports$lab.before,
    beforeEach = _exports$lab.beforeEach;

var source = void 0;
var expected = void 0;
var mapper = void 0;
var actual = void 0;

describe("Pipeline Transformations", function () {

  describe("The accceptIf() method", function () {

    before(function () {
      mapper = (0, _lib2.default)();

      mapper.map("foo").acceptIf("voila", "a").to("bar").map("foo").acceptIf("check", function (check) {
        return check > 5;
      }).to("bar1").map("foo").acceptIf("check", function (check) {
        return check > 1;
      }).to("bar2");

      source = {
        "foo": {
          "id": "fooID",
          "bar": "tes",
          "foo1": "bar2"
        },
        "voila": "a",
        "check": 2
      };

      expected = {
        "bar": {
          "id": "fooID",
          "bar": "tes",
          "foo1": "bar2"
        },
        "bar2": {
          "id": "fooID",
          "bar": "tes",
          "foo1": "bar2"
        }
      };
    });

    describe("when its used", function () {

      it("should return the desired result", function () {
        actual = mapper.execute(source);
        (0, _code.expect)(actual).to.equal(expected);
      });
    });

    describe("parameter validation", function () {

      before(function () {
        mapper = (0, _lib2.default)();
      });

      it("should throw an error if key is null", function () {
        (0, _code.expect)(function () {
          return mapper("foo").acceptIf(null).to("bar");
        }).to.throw("the key must be a string");
      });

      it("should throw an error if value is null", function () {
        (0, _code.expect)(function () {
          return mapper("foo").acceptIf("foo").to("bar");
        }).to.throw("the value cannot be undefined or null");
      });
    });

    describe("when multiple sources are provided", function () {
      before(function () {
        mapper = (0, _lib2.default)();
      });

      it("should throw an error", function () {
        (0, _code.expect)(function () {
          return mapper.map(["foo", "bar"]).acceptIf("foo", 2);
        }).to.throw("Multiple selections does not support pipeline transformations");
      });
    });
  });

  describe("The rejectIf() method", function () {

    before(function () {
      mapper = (0, _lib2.default)();

      mapper.map("foo").rejectIf("voila", "a").to("bar").map("foo").rejectIf("check", function (check) {
        return check > 5;
      }).to("bar1").map("foo").rejectIf("check", function (check) {
        return check > 1;
      }).to("bar2");

      source = {
        "foo": {
          "id": "fooID",
          "bar": "tes",
          "foo1": "bar2"
        },
        "voila": "a",
        "check": 2
      };

      expected = {
        "bar1": {
          "id": "fooID",
          "bar": "tes",
          "foo1": "bar2"
        }
      };
    });

    describe("when its used", function () {

      it("should return the desired result", function () {
        actual = mapper.execute(source);
        (0, _code.expect)(actual).to.equal(expected);
      });
    });

    describe("parameter validation", function () {

      before(function () {
        mapper = (0, _lib2.default)();
      });

      it("should throw an error if key is null", function () {
        (0, _code.expect)(function () {
          return mapper("foo").rejectIf(null).to("bar");
        }).to.throw("the key must be a string");
      });

      it("should throw an error if value is null", function () {
        (0, _code.expect)(function () {
          return mapper("foo").rejectIf("foo").to("bar");
        }).to.throw("the value cannot be undefined or null");
      });
    });

    describe("when multiple sources are provided", function () {
      before(function () {
        mapper = (0, _lib2.default)();
      });

      it("should throw an error", function () {
        (0, _code.expect)(function () {
          return mapper.map(["foo", "bar"]).rejectIf("foo", 2);
        }).to.throw("Multiple selections does not support pipeline transformations");
      });
    });
  });

  describe("The removing() method", function () {

    before(function () {
      mapper = (0, _lib2.default)();

      mapper.map("foo").removing(["id", "foo1"]).to("bar").map("fooArray").removing(["id"]).to("barArray").map("h").or("howdy").removing(["id2"]).to("orTest").map("howdy").map("voila").to("voila", function () {
        return "hello";
      });

      source = {
        "foo": {
          "id": "fooID",
          "bar": "tes",
          "foo1": "bar2"
        },
        "fooArray": [{
          "id": "fooID",
          "bar": "tes",
          "foo1": "bar2"
        }],
        "howdy": {
          "id": "allow",
          "id2": "allow2"
        },
        "voila": "a"
      };

      expected = {
        "bar": {
          "bar": "tes"
        },
        "barArray": [{
          "bar": "tes",
          "foo1": "bar2"
        }],
        "howdy": {
          "id": "allow",
          "id2": "allow2"
        },
        "orTest": {
          "id": "allow"
        },
        "voila": "hello"
      };
    });

    describe("when an object is passed", function () {

      it("should return the desired result", function () {
        actual = mapper.execute(source);
        (0, _code.expect)(actual).to.equal(expected);
      });
    });

    describe("when an array of object is passed", function () {

      it("should return the desired result", function () {
        actual = mapper.each([source]);
        (0, _code.expect)(actual).to.equal([expected]);
      });
    });

    describe("parameter validation", function () {

      beforeEach(function () {
        mapper = (0, _lib2.default)();
      });

      it("should throw an error on null", function () {
        (0, _code.expect)(function () {
          return mapper("foo").removing(null).to("bar");
        }).to.throw("The removing method requires a string value or an array of strings");
      });

      it("should throw an error on undefined", function () {
        (0, _code.expect)(function () {
          return mapper("foo").removing(undefined).to("bar");
        }).to.throw("The removing method requires a string value or an array of strings");
      });

      it("should throw an error when keys are not passed in as valid string", function () {
        (0, _code.expect)(function () {
          return mapper("foo").removing({}).to("bar");
        }).to.throw("The removing method requires a string value or an array of strings");
      });

      it("should throw an error when keys are not passed in as valid array of strings", function () {
        (0, _code.expect)(function () {
          return mapper("foo").removing([{}]).to("bar");
        }).to.throw("The removing method requires a string value or an array of strings");
      });
    });

    describe("when multiple sources are provided", function () {
      before(function () {
        mapper = (0, _lib2.default)();
      });

      it("should throw an error", function () {
        (0, _code.expect)(function () {
          return mapper.map(["foo", "bar"]).removing("foo");
        }).to.throw("Multiple selections does not support pipeline transformations");
      });
    });
  });

  describe("The compact() method", function () {

    it("should compact and array with falsy values", function () {

      var input = [null, "a", false, "b", undefined, "c"];

      expected = ["a", "b", "c"];

      mapper = (0, _lib2.default)();

      actual = mapper.map("[]").compact().execute(input);

      (0, _code.expect)(actual).to.equal(expected);
    });

    it("should return an unmodified value if the source value is not an array", function () {
      var input = { data: { "first": "value", "second": null } };
      mapper = (0, _lib2.default)();

      actual = mapper.map("data").compact().execute(input);

      (0, _code.expect)(actual).to.equal(input);
    });

    it("should not error if the source value isn't found", function () {
      var input = {};
      mapper = (0, _lib2.default)();

      actual = mapper.map("data").compact().execute(input);

      (0, _code.expect)(actual).to.equal(input);
    });

    describe("when multiple sources are provided", function () {
      before(function () {
        mapper = (0, _lib2.default)();
      });

      it("should throw an error", function () {
        (0, _code.expect)(function () {
          return mapper.map(["foo", "bar"]).compact();
        }).to.throw("Multiple selections does not support pipeline transformations");
      });
    });
  });

  describe("The first() method", function () {

    it("should select the first item in an array", function () {

      var input = ["a", "b", "c"];

      expected = { data: "a" };

      mapper = (0, _lib2.default)();

      actual = mapper.map("[]").first().to("data").execute(input);

      (0, _code.expect)(actual).to.equal(expected);
    });

    it("should return an unmodified value if the source value is not an array", function () {
      var input = { data: { "first": "value", "second": null } };
      mapper = (0, _lib2.default)();

      actual = mapper.map("data").first().execute(input);

      (0, _code.expect)(actual).to.equal(input);
    });

    it("should not error if the source value isn't found", function () {
      var input = {};
      mapper = (0, _lib2.default)();

      actual = mapper.map("data").first().execute(input);

      (0, _code.expect)(actual).to.equal(input);
    });

    describe("when multiple sources are provided", function () {
      before(function () {
        mapper = (0, _lib2.default)();
      });

      it("should throw an error", function () {
        (0, _code.expect)(function () {
          return mapper.map(["foo", "bar"]).first();
        }).to.throw("Multiple selections does not support pipeline transformations");
      });
    });
  });

  describe("The last() method", function () {

    it("should select the first item in an array", function () {

      var input = ["a", "b", "c"];

      expected = { data: "c" };

      mapper = (0, _lib2.default)();

      actual = mapper.map("[]").last().to("data").execute(input);

      (0, _code.expect)(actual).to.equal(expected);
    });

    it("should return an unmodified value if the source value is not an array", function () {
      var input = { data: { "first": "value", "second": null } };
      mapper = (0, _lib2.default)();

      actual = mapper.map("data").last().execute(input);

      (0, _code.expect)(actual).to.equal(input);
    });

    it("should not error if the source value isn't found", function () {
      var input = {};
      mapper = (0, _lib2.default)();

      actual = mapper.map("data").last().execute(input);

      (0, _code.expect)(actual).to.equal(input);
    });

    describe("when multiple sources are provided", function () {
      before(function () {
        mapper = (0, _lib2.default)();
      });

      it("should throw an error", function () {
        (0, _code.expect)(function () {
          return mapper.map(["foo", "bar"]).last();
        }).to.throw("Multiple selections does not support pipeline transformations");
      });
    });
  });

  describe("The keep() method", function () {

    before(function () {
      mapper = (0, _lib2.default)();

      mapper.map("foo").keep(["foo1", "foo2"]).to("bar").map("fooArray").keep(["bar", "foo1"]).to("barArray").map("h").or("howdy").keep(["id"]).to("orTest").map("howdy").map("voila").to("voila", function () {
        return "hello";
      });

      source = {
        "foo": {
          "id": "fooID",
          "bar": "tes",
          "foo1": "bar2"
        },
        "fooArray": [{
          "id": "fooID",
          "bar": "tes",
          "foo1": "bar2"
        }],
        "howdy": {
          "id": "allow",
          "id2": "allow2"
        },
        "voila": "a"
      };

      expected = {
        "bar": {
          "foo1": "bar2"
        },
        "barArray": [{
          "bar": "tes",
          "foo1": "bar2"
        }],
        "howdy": {
          "id": "allow",
          "id2": "allow2"
        },
        "orTest": {
          "id": "allow"
        },
        "voila": "hello"
      };
    });

    describe("when an object is passed", function () {

      it("should return the desired result", function () {
        actual = mapper.execute(source);
        (0, _code.expect)(actual).to.equal(expected);
      });
    });

    describe("when an array of object is passed", function () {

      it("should return the desired result", function () {
        actual = mapper.each([source]);
        (0, _code.expect)(actual).to.equal([expected]);
      });
    });

    describe("parameter validation", function () {

      beforeEach(function () {
        mapper = (0, _lib2.default)();
      });

      it("should throw an error on null", function () {
        (0, _code.expect)(function () {
          return mapper("foo").keep(null).to("bar");
        }).to.throw("The keep method requires a string value or an array of strings");
      });

      it("should throw an error on undefined", function () {
        (0, _code.expect)(function () {
          return mapper("foo").keep(undefined).to("bar");
        }).to.throw("The keep method requires a string value or an array of strings");
      });

      it("should throw an error when keys are not passed in as valid string", function () {
        (0, _code.expect)(function () {
          return mapper("foo").keep({}).to("bar");
        }).to.throw("The keep method requires a string value or an array of strings");
      });

      it("should throw an error when keys are not passed in as valid array of strings", function () {
        (0, _code.expect)(function () {
          return mapper("foo").keep([{}]).to("bar");
        }).to.throw("The keep method requires a string value or an array of strings");
      });
    });

    describe("when multiple sources are provided", function () {
      before(function () {
        mapper = (0, _lib2.default)();
      });

      it("should throw an error", function () {
        (0, _code.expect)(function () {
          return mapper.map(["foo", "bar"]).keep("foo");
        }).to.throw("Multiple selections does not support pipeline transformations");
      });
    });
  });
});
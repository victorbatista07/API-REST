"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require("lodash.clonedeep");

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require("lodash.unset");

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require("lodash.set");

var _lodash6 = _interopRequireDefault(_lodash5);

var _lodash7 = require("lodash.compact");

var _lodash8 = _interopRequireDefault(_lodash7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Mapping = function () {
  function Mapping(source, mapper, options) {
    _classCallCheck(this, Mapping);

    this.mapper = mapper;
    this.source = source;
    this.orMode = false;
    this.alwaysSet = options.alwaysSet;
    this.alwaysTransform = options.alwaysTransform;
    this.flatten = options.flatten;
    this.flattenInverted = options.flattenInverted;
    this.pipelineTransformations = [];
  }

  _createClass(Mapping, [{
    key: "validateSourceForOps",
    value: function validateSourceForOps() {
      if (Array.isArray(this.source) && this.orMode === false) {
        throw new Error("Multiple selections does not support pipeline transformations");
      }
    }
  }, {
    key: "pushToPipelineTransformations_",
    value: function pushToPipelineTransformations_(func) {
      this.pipelineTransformations.push(func);
    }
  }, {
    key: "with",
    value: function _with(optionOverrides) {

      var permittedOptions = ["flatten", "flattenInverted", "alwaysSet", "alwaysTransform"];

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = permittedOptions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var option = _step.value;

          this[option] = optionOverrides[option] === undefined ? this[option] : optionOverrides[option];
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return this;
    }
  }, {
    key: "map",
    value: function map(stringOrArray) {
      return this.mapper.map(stringOrArray);
    }
  }, {
    key: "or",
    value: function or(source) {

      if (!source) {
        throw new Error("'source' is required for the 'or' method");
      }

      if (Array.isArray(source)) {
        throw new Error("The 'or' method can only be used with single selections");
      }

      if (Array.isArray(this.source) && this.orMode === false) {
        throw new Error("The 'or' method can only be used with single selections");
      }

      this.orMode = true;

      if (Array.isArray(this.source)) {

        var sourceArray = this.source;

        sourceArray.push(source);

        return this;
      }

      var newSource = [];
      newSource.push(this.source);
      newSource.push(source);

      this.source = newSource;

      return this;
    }
  }, {
    key: "execute",
    value: function execute(source, destination) {
      return this.mapper.execute(source, destination);
    }
  }, {
    key: "executeAsync",
    value: function executeAsync(source, destination) {
      return this.mapper.executeAsync(source, destination);
    }
  }, {
    key: "each",
    value: function each(sourceArray) {
      return this.mapper.each(sourceArray);
    }
  }, {
    key: "chain",
    value: function chain(mapper) {
      return this.mapper.chain(mapper);
    }
  }, {
    key: "set",
    value: function set(key, value) {
      return this.mapper.set(key, value);
    }
  }, {
    key: "to",
    value: function to(target, successFunc, notFoundFunc) {

      if (!target || typeof target !== "string") {
        throw new Error("the target field name must be a string");
      }

      this.target = target;

      if (successFunc) {
        this.transform = successFunc;
      }

      if (notFoundFunc) {
        this.failureTransform = notFoundFunc;
      }

      return this.mapper;
    }
  }, {
    key: "acceptIf",
    value: function acceptIf(key, val) {
      var _this = this;

      this.validateSourceForOps();

      if (typeof key !== "string") {
        throw new Error("the key must be a string");
      }

      if (val === undefined || val === null) {
        throw new Error("the value cannot be undefined or null");
      }

      this.pushToPipelineTransformations_(function (source, value) {
        var path = key;
        var condition = val;

        var valueToUse = _this.mapper.om.getValue(source, path);

        if (typeof condition === "function") {
          return condition(valueToUse) === true ? value : null;
        }

        return valueToUse === condition ? value : null;
      });

      return this;
    }
  }, {
    key: "rejectIf",
    value: function rejectIf(key, val) {
      var _this2 = this;

      this.validateSourceForOps();

      if (typeof key !== "string") {
        throw new Error("the key must be a string");
      }

      if (val === undefined || val === null) {
        throw new Error("the value cannot be undefined or null");
      }

      this.pushToPipelineTransformations_(function (source, value) {
        var path = key;
        var condition = val;

        var valueToUse = _this2.mapper.om.getValue(source, path);

        if (typeof condition === "function") {
          return condition(valueToUse) === false ? value : null;
        }

        return valueToUse === condition === false ? value : null;
      });

      return this;
    }
  }, {
    key: "compact",
    value: function compact() {
      this.validateSourceForOps();

      this.pushToPipelineTransformations_(function (source, value) {

        if (!Array.isArray(value)) {
          return value;
        }

        return (0, _lodash8.default)(value);
      });
      return this;
    }
  }, {
    key: "first",
    value: function first() {
      this.validateSourceForOps();

      this.pushToPipelineTransformations_(function (source, value) {

        if (!Array.isArray(value)) {
          return value;
        }

        return value[0];
      });

      return this;
    }
  }, {
    key: "last",
    value: function last() {
      this.validateSourceForOps();

      this.pushToPipelineTransformations_(function (source, value) {

        if (!Array.isArray(value)) {
          return value;
        }

        return value[value.length - 1];
      });

      return this;
    }
  }, {
    key: "keep",
    value: function keep(keys) {
      var _this3 = this;

      this.validateSourceForOps();

      if (Array.isArray(keys) && keys.length > 0) {
        keys.map(function (key) {
          if (typeof key !== "string") {
            throw new Error("The keep method requires a string value or an array of strings");
          }
        });
      }

      if (Array.isArray(keys) === false && typeof keys !== "string") {
        throw new Error("The keep method requires a string value or an array of strings");
      }

      this.pushToPipelineTransformations_(function (source, value) {

        var valueToUse = (0, _lodash2.default)(value);

        if ((typeof valueToUse === "undefined" ? "undefined" : _typeof(valueToUse)) !== "object" && !Array.isArray(valueToUse)) {
          return valueToUse;
        }

        var isArray = Array.isArray(valueToUse) && valueToUse.length > 0;

        if (isArray) {
          valueToUse = valueToUse.map(function (val) {
            if ((typeof val === "undefined" ? "undefined" : _typeof(val)) !== "object" && !Array.isArray(val)) {
              return val;
            }
            return _this3.processKeep_(keys, val);
          });
        } else {
          valueToUse = _this3.processKeep_(keys, valueToUse);
        }
        return valueToUse;
      });

      return this;
    }
  }, {
    key: "processKeep_",
    value: function processKeep_(keys, val) {

      var obj = {};

      if (Array.isArray(keys) && keys.length > 0) {
        keys.map(function (key) {
          if (val[key]) {
            (0, _lodash6.default)(obj, key, val[key]);
          }
        });

        return obj;
      }

      if (typeof keys === "string") {
        (0, _lodash6.default)(obj, keys, val[keys]);
        return obj;
      }
    }
  }, {
    key: "removing",
    value: function removing(keys) {
      var _this4 = this;

      this.validateSourceForOps();

      if (Array.isArray(keys) && keys.length > 0) {
        keys.map(function (key) {
          if (typeof key !== "string") {
            throw new Error("The removing method requires a string value or an array of strings");
          }
        });
      }

      if (Array.isArray(keys) === false && typeof keys !== "string") {
        throw new Error("The removing method requires a string value or an array of strings");
      }

      this.pushToPipelineTransformations_(function (source, value) {

        var valueToUse = (0, _lodash2.default)(value);

        if ((typeof valueToUse === "undefined" ? "undefined" : _typeof(valueToUse)) !== "object" && !Array.isArray(valueToUse)) {
          return valueToUse;
        }

        var isArray = Array.isArray(valueToUse) && valueToUse.length > 0;

        if (isArray) {
          valueToUse = valueToUse.map(function (val) {
            if ((typeof val === "undefined" ? "undefined" : _typeof(val)) !== "object" && !Array.isArray(val)) {
              return val;
            }
            return _this4.processRemoving_(keys, val);
          });
        } else {
          valueToUse = _this4.processRemoving_(keys, valueToUse);
        }
        return valueToUse;
      });

      return this;
    }
  }, {
    key: "processRemoving_",
    value: function processRemoving_(keys, val) {

      if (Array.isArray(keys) && keys.length > 0) {
        keys.map(function (key) {
          (0, _lodash4.default)(val, key);
        });

        return val;
      }

      if (typeof keys === "string") {
        (0, _lodash4.default)(val, keys);
        return val;
      }
    }
  }, {
    key: "always",
    get: function get() {
      this.alwaysSet = true;
      this.alwaysTransform = true;
      return this;
    }
  }, {
    key: "existing",
    get: function get() {
      this.alwaysSet = false;
      this.alwaysTransform = false;
      return this;
    }
  }]);

  return Mapping;
}();

exports.default = Mapping;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _mapping = require("./mapping");

var _mapping2 = _interopRequireDefault(_mapping);

var _lodash = require("lodash.flattendeep");

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require("lodash.flattendepth");

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require("lodash.clonedeep");

var _lodash6 = _interopRequireDefault(_lodash5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SINGLE_MODE = 0;
var MULTI_MODE = 1;
var OR_MODE = 2;

var isValueArray = new RegExp(/^\[\]|\[\d+\]/);

var Mapper = function () {
  function Mapper(opts, om) {
    _classCallCheck(this, Mapper);

    this.om = om;
    this.experimental = opts.experimental;
    this.options = opts;

    this.assignment = [];
    this.mapCache_ = null;

    this.chainArray = [];
  }

  _createClass(Mapper, [{
    key: "registerMapping_",
    value: function registerMapping_(mapping) {

      this.assignment.push(mapping);
    }
  }, {
    key: "map",
    value: function map(source) {

      // create a mapping for a single or multiple source field(s) and return the mapping object
      // the mapping object enables the fluent/chainable interface

      var mapping = new _mapping2.default(source, this, this.options);
      this.registerMapping_(mapping);

      return mapping;
    }
  }, {
    key: "set",
    value: function set(key, value) {
      if (typeof key !== "string") {
        throw new Error("the key must be a string");
      }
      if (typeof value === "function") {
        return this.map(key).always.to(key, value);
      }
      return this.map(key).always.to(key, function () {
        return value;
      });
    }
  }, {
    key: "each",
    value: function each(sourceArray) {
      var _this = this;

      // validate inputs
      if (!sourceArray) {
        // TODO: This should probably return undefined
        return null;
      }

      if (Array.isArray(sourceArray) !== true) {
        throw new Error("The sourceArray parameter must be an array");
      }

      // iterate over an array of values and map each one
      return sourceArray.map(function (item) {
        return _this.execute(item, null);
      });
    }
  }, {
    key: "execute",
    value: function execute(source, destination) {

      // validate inputs
      if (source === null || source === undefined) {
        throw new Error("A source object is required");
      }

      // ensure we have a destination object to target
      if (destination === null || destination === undefined) {
        destination = {};
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.assignment[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var item = _step.value;


          // TODO: This method should be done at map declaration not at execution
          var descriptor = this.getTransformDescriptor_(item);

          // annoyingly, VS Code's auto format is at odds with eslint
          /* eslint-disable indent */

          // map-factory supports 3 modes:
          // - single source mode -> mapper.map("field1")
          // - multiple sources mode -> mapper.map(["field1", "field2"])
          // - or mode -> mapper.map("field1").or("field2")

          // Here we just route the mode to the appropriate logic
          switch (descriptor.mode) {
            case SINGLE_MODE:
              destination = this.processSingleItem_(source, destination, descriptor);
              break;
            case MULTI_MODE:
              destination = this.processMultiItem_(source, destination, descriptor);
              break;
            case OR_MODE:
              destination = this.processOrItem_(source, destination, descriptor);
              break;
            default:
              throw new Error("Invalid Mapping Mode: mode was " + descriptor.mode);
          }
          /* eslint-enable indent */
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      destination = this.handleChain_(destination);

      return destination;
    }
  }, {
    key: "executeAsync",
    value: function executeAsync(source, destination) {
      var _this2 = this;

      return Promise.resolve().then(function () {
        return _this2.execute(source, destination);
      });
    }
  }, {
    key: "chain",
    value: function chain(mapper) {
      if (mapper === null || mapper === undefined) {
        throw new Error("mapper passed in chain can neither be null or undefined");
      }
      this.chainArray.push(mapper);
      return this;
    }
  }, {
    key: "handleChain_",
    value: function handleChain_(destination) {

      if (this.chainArray.length > 0) {
        this.chainArray.map(function (item) {
          destination = item.execute(destination);
        });
      }

      return destination;
    }
  }, {
    key: "getTransformDescriptor_",
    value: function getTransformDescriptor_(item) {

      /* eslint-disable prefer-const */
      var sourcePath = item.source;
      var targetPath = item.target;
      var transform = item.transform,
          alwaysSet = item.alwaysSet,
          alwaysTransform = item.alwaysTransform,
          pipelineTransformations = item.pipelineTransformations,
          flatten = item.flatten,
          flattenInverted = item.flattenInverted,
          failureTransform = item.failureTransform;


      var isCustomTransform = true;
      /* eslint-enable prefer-const */

      // TODO: offload to Mapping declaration
      var mode = this.decideMode_(item);
      var flattenings = this.decideArrayFlattening_(sourcePath, targetPath, flatten, flattenInverted);

      if (!transform) {
        isCustomTransform = false;
        transform = function transform(value) {
          return value;
        };
      }

      if (!failureTransform && this.options.failureTransform) {
        failureTransform = this.options.failureTransform;
      }

      if (failureTransform && typeof failureTransform !== "function") {
        var valueToReturn = failureTransform;
        failureTransform = function failureTransform() {
          return valueToReturn;
        };
      }

      if (!targetPath) {
        targetPath = sourcePath;
      }

      return { mode: mode, targetPath: targetPath, sourcePath: sourcePath, transform: transform, failureTransform: failureTransform, isCustomTransform: isCustomTransform, flattenings: flattenings, options: { alwaysSet: alwaysSet, alwaysTransform: alwaysTransform, pipelineTransformations: pipelineTransformations, flatten: flatten, flattenInverted: flattenInverted } };
    }
  }, {
    key: "decideArrayFlattening_",
    value: function decideArrayFlattening_(sourcePathOrArray, targetPath, flattenFlag, flattenInverted) {

      // some scenarios will supply an array not a string. Normalise it here.
      var sourcePaths = Array.isArray(sourcePathOrArray) ? sourcePathOrArray : [sourcePathOrArray];
      var flattenings = [];

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = sourcePaths[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var sourcePath = _step2.value;


          // Check to see if the user has overriden default flattening behaviour
          var flattening = this.processSources_(sourcePath, targetPath, flattenInverted);
          flattening.flatten = flattenFlag !== null ? flattenFlag : flattening.flatten;

          flattenings.push(flattening);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return flattenings;
    }
  }, {
    key: "processSources_",
    value: function processSources_(sourcePath, targetPath, flattenInverted) {

      // no target means that the source is used as the target (same number of arrays)
      // so in this scenario we just suppress flattening
      // no source means copy the root object so we dont need this
      if (targetPath === null || targetPath === undefined || sourcePath === null || sourcePath === undefined) {
        return { sourceCount: 0, targetCount: 0, flatten: false, inverted: flattenInverted };
      }

      // const regArray = /\[\]|\[([\w\.'=]*)\]/g; use for support of jsonata-like query
      var regArray = /\[\]|\[([\w]*)\]/g;

      // Figure out source has move levels that target
      var sourceCount = sourcePath.match(regArray);
      var targetCount = targetPath.match(regArray);

      sourceCount = sourceCount === null ? sourceCount = 0 : sourceCount.length;
      targetCount = targetCount === null ? targetCount = 0 : targetCount.length;

      if (sourceCount > targetCount) {
        // we need to flatten this array to match the target structure
        return { sourceCount: sourceCount, targetCount: targetCount, flatten: true, inverted: flattenInverted };
      }

      return { sourceCount: sourceCount, targetCount: targetCount, flatten: false, inverted: flattenInverted };
    }
  }, {
    key: "decideMode_",
    value: function decideMode_(item) {

      var isArray = Array.isArray(item.source);

      if (isArray === false) {
        return SINGLE_MODE;
      }

      if (isArray === true && item.orMode === false) {
        return MULTI_MODE;
      }

      return OR_MODE;
    }
  }, {
    key: "processSingleItem_",
    value: function processSingleItem_(sourceObject, destinationObject, _ref) {
      var targetPath = _ref.targetPath,
          sourcePath = _ref.sourcePath,
          transform = _ref.transform,
          failureTransform = _ref.failureTransform,
          flattenings = _ref.flattenings,
          options = _ref.options;


      // Get source
      var value = void 0;

      if (!sourcePath) {
        value = (0, _lodash6.default)(sourceObject);
      } else {
        value = this.om.getValue(sourceObject, sourcePath);
      }
      var flattening = flattenings[0];

      // default transformations
      if (this.exists_(value) && options.pipelineTransformations.length > 0) {
        options.pipelineTransformations.map(function (item) {
          value = item(sourceObject, value);
        });
      }

      value = this.flattenValue_(flattening, value);

      // Apply transform if required
      if (this.exists_(value) || options.alwaysTransform === true) {
        value = transform(value);
      }

      if (!this.exists_(value) && failureTransform) {
        value = failureTransform(value);
      }

      // Set value on destination object
      if (!targetPath) {
        destinationObject = value;
        return destinationObject;
      }
      return this.setIfRequired_(destinationObject, targetPath, value, options);
    }
  }, {
    key: "processMultiItem_",
    value: function processMultiItem_(sourceObject, destinationObject, _ref2) {
      var sourcePath = _ref2.sourcePath,
          targetPath = _ref2.targetPath,
          transform = _ref2.transform,
          failureTransform = _ref2.failureTransform,
          isCustomTransform = _ref2.isCustomTransform,
          flattenings = _ref2.flattenings,
          options = _ref2.options;


      if (isCustomTransform === false) {
        throw new Error("Multiple selections must map to a transform. No transform provided.");
      }

      var values = [];
      var anyValues = false;

      // Get source
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = sourcePath[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var fromKey = _step3.value;


          var _value = this.om.getValue(sourceObject, fromKey);

          if (this.exists_(_value)) {
            anyValues = true;
          }

          values.push(_value);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var value = void 0;

      // default transformations
      if (anyValues && options.pipelineTransformations.length > 0) {
        options.pipelineTransformations.map(function (item) {
          values = item(sourceObject, values);
        });
      }

      // flatten values if required
      for (var i = 0; i < values.length; i++) {
        values[i] = this.flattenValue_(flattenings[i], values[i]);
      }

      // Apply transform if appropriate
      if (anyValues || options.alwaysTransform === true) {
        value = transform.apply(undefined, _toConsumableArray(values));
      }

      if (!anyValues && failureTransform) {
        value = failureTransform(value);
      }

      // Set value on destination object
      return this.setIfRequired_(destinationObject, targetPath, value, options);
    }
  }, {
    key: "processOrItem_",
    value: function processOrItem_(sourceObject, destinationObject, _ref3) {
      var sourcePath = _ref3.sourcePath,
          targetPath = _ref3.targetPath,
          transform = _ref3.transform,
          failureTransform = _ref3.failureTransform,
          flattenings = _ref3.flattenings,
          options = _ref3.options;


      var orValue = void 0;
      var sourceArray = sourcePath;
      var i = 0;

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = sourceArray[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var sourceKey = _step4.value;


          orValue = this.om.getValue(sourceObject, sourceKey);

          if (orValue !== null && orValue !== undefined) {
            break;
          }

          i++;
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      var flattening = flattenings[i];

      // default transformations
      if (this.exists_(orValue) && options.pipelineTransformations.length > 0) {
        options.pipelineTransformations.map(function (item) {
          orValue = item(sourceObject, orValue);
        });
      }

      orValue = this.flattenValue_(flattening, orValue);

      // has a transform
      if (this.exists_(orValue) || options.alwaysTransform === true) {
        orValue = transform(orValue);
      }

      if (!this.exists_(orValue) && failureTransform) {
        orValue = failureTransform(orValue);
      }

      return this.setIfRequired_(destinationObject, targetPath, orValue, options);
    }
  }, {
    key: "setIfRequired_",
    value: function setIfRequired_(destinationObject, targetPath, value, options) {

      if (this.exists_(value) || options.alwaysSet === true) {
        return this.om.setValue(destinationObject, targetPath, value);
      }

      if (this.isEmptyObject_(destinationObject) && isValueArray.exec(targetPath) !== null) {
        return [];
      }

      return destinationObject;
    }
  }, {
    key: "flattenValue_",
    value: function flattenValue_(flattening, value) {

      if (flattening !== undefined && flattening.flatten === true) {
        var seekDepth = flattening.targetCount - 1;

        if (flattening.inverted === true) {
          return (0, _lodash4.default)(value, flattening.sourceCount - flattening.targetCount);
        }

        return this.flattenArray_(value, seekDepth);
      }

      return value;
    }
  }, {
    key: "flattenArray_",
    value: function flattenArray_(valueArray, seekDepth) {
      var currentDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;


      if (Array.isArray(valueArray) === false) return valueArray;
      if (valueArray.length === 0) return valueArray;

      if (seekDepth === currentDepth) {
        valueArray = (0, _lodash2.default)(valueArray);
        // console.log("valueArray final:", valueArray);
        return valueArray;
      }

      // value is always an array
      for (var i = 0; i < valueArray.length; i++) {
        var newDepth = currentDepth + 1;
        valueArray[i] = this.flattenArray_(valueArray[i], seekDepth, newDepth);
      }

      // console.log("valueArray:", valueArray);
      return valueArray;
    }
  }, {
    key: "isEmptyObject_",
    value: function isEmptyObject_(object) {
      return (typeof object === "undefined" ? "undefined" : _typeof(object)) === "object" && Array.isArray(object) === false && Object.keys(object).length === 0;
    }
  }, {
    key: "exists_",
    value: function exists_(value) {
      return value !== null && value !== undefined;
    }
  }]);

  return Mapper;
}();

exports.default = Mapper;